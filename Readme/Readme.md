# LabN2
## Отчет по лабораторной работе № 2

#### № группы: `ПМ-2402`

#### Выполнил: `Савушкин Павел Павлович`

#### Вариант: `21`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи

- Условия задачи

> Программа получает на вход два целых числа N и M. Считывает N*M элементов (также целые числа), формируя двумерный массив. Далее программа делает такие действия, как вывод уникальных элементов массива, сортировка столбцов (по возрастанию) по сумме элементов и количеству уникальных чисел в этих столбцах (при равенстве сумм), вывод элементы массива по диагоналям, начиная с верхней левой и вывод замены чисел на их факториал.
  

- Поставленную задачу можно разбить на несколько подзадач:
-   1. Считывание размера матрицы и ее элементы.
    2. Счет количество уникальных элементов.
    3. Сортировка методом пузырька по нужным нам условиям.
    4. Вывод данных по левой диагонали.
    5. Вычисление и вывод факториала каждого элемента.

### 2. Входные и выходные данные

#### Данные на вход

На вход программа должна получать 2 целых числа N и M. Но так как эти числа задают количество строк и столбцов в двумерном массиве, то они не могут принимать неположительные значения. Так как нам не указали диапазон, то сделаем его самостоятельно, при котором минимальное значение N и M будет 1. Максимальное значение - 2<sup>31</sup>. Так как последний вывод - факториалы чисел, то ограничим значения a[i][j] от -12 до 12 включительно, чтобы "уместиться" в половину ячейки int (2<sup>31</sup>). Также, если нам попалось отрицательное число, то заменим его факториал на символ "#".

|             | Тип                | min значение    | max значение   |
|-------------|--------------------|-----------------|----------------|
| a[i][j]     | Целое число        |      -12        |       12       |
| N (Число 1) | Целое число        |        1        | 2<sup>31</sup> |
| M (Число 2) | Целое число        |        1        | 2<sup>31</sup> |

#### Данные на выход

Программа делает 3 вывода: количество уникальных значений, отсортированный массив по диагонали, массив факториалов предыдущих чисел (размер массива не изменяются). Рассмотрим случай, если a[i][j]<0. Тогда будет выводиться символ вместо этого отрицательного элемента

|          | Тип                | min значение  |      max значение    |
|----------|--------------------|---------------|----------------------|
| Count    | Целое число        |       0       |N*M или 2<sup>62</sup>|
| a[i][j]  | Целое число        |     -12       |          12          |
|(a[i][j])!| Целое число        |       1       | 12!(<2<sup>31</sup>) |
| Строка   | String             |       -       |           -          |

### 3. Выбор структуры данных

Программа получает 2 целых числа, N и M, значения которых мы указали ранее. Для их хранения будем использовать переменные (N;M) типа int. Укажу также счетчик count, который будет также хранится в переменной типа int по причине того, что она зависит от a[i][j] и N*M (не будет принимать большие значения тк a[i][j] в пределах от 1 до 12 включительно).

|             | название переменной | Тип (в Java) | 
|-------------|---------------------|--------------|
| N           | `N`                 | `int`        |
| M           | `M`                 | `int`        | 
| count       | `count`             | `int`        |


### 4. Алгоритм

#### Математическая модель:
  Рассмотрим, как реализуется вывод элементов двумерного массива по диагоналям, начиная с первого элемента.
  а) В двумерном массиве, можно заметить, что диагонали можно опредеить по сумме индексов элементов. В нашем случаее, для элемента a[i][j] диагональ определяется как d = i + j. Так, все элементы, находящиеся на одной диагонали имеют одинаковую сумму (d).
  б) Я разделил этам вывода диагоналей на 2 части: Вывод элементов с первой строки (пункт №1) и вывод элементов с первого столбца( пункт №2)

№1. **Вывод, начиная, с первой строки:**  
  Для каждого столбца j (от 0 до M-1), начиная с элемента A[0][j], идем вниз по диагонали, увеличивая индекс строки x (начинается с 0) и уменьшая индекс строки y (начинается с j). Пока y не станет отрицательным и x меньше N, программа продолжается
  
№2. **Вывод, начиная, с левого столбца:**    
  После того, как выполнен пункт #1 программа продолжает вывод диагонали с с i=1. При выводе диагоналей, начиная с левого столбца, мы должны учитывать, что мы начинаем с каждой строки, начиная с первой строки (индекс 1), и продолжаем до последней строки. При этом мы начинаем с последнего столбца (индекс M - 1) и движемся по диагонали вниз.

  Приведу пример.
Рассмотрим массив E:
  i/j | 0 | 1 | 1 |
  |---|---|---|---|
  | 0 | 1 | 2 | 3 |
  | 1 | 4 | 5 | 6 |
  | 2 | 7 | 8 | 9 |

Вывод №1.
Начнем с верхнего ряда.
При i = 0 => 1.
При i = 1 => 2, 4.
При i = 2 => 3, 5, 7.

Вывод №2.                        
Начнем с правого стобца.
При i = 1 => 6, 8.
При i = 2 => 9.

![image](https://github.com/user-attachments/assets/b88a1f43-2c0e-4beb-8265-077cdb8cf90b)
                        

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа сначала считывает два значения: N (количество строк) и M (количество столбцов). Для этого используется метод nextInt().

2. **Создание и заполнение матрицы**  
   Программа создает двумерный массив a размером N*M, используя вложенные циклы для заполнения матрицы: внешний проходит по строкам ( от 0 до N-1 ), внутренний - по столбцам ( от 0 до M-1 ). А для каждого элемента запрашивает у тестировщика число, сохраняя его в ячейку a[i][j].
                                                      
3. **Подсчет и вывод уникальных элементов**
   Программа создает переменную count для хранения уникальных элементов всего массива. Затем использует два вложенных цикла ( первый :внешний проходит по строкам ( от 0 до N-1 ), внутренний - по столбцам ( от 0 до M-1 ), а второй: проверка предыдущих элементов на наличие текцщего ) для проверки условия. Инициализация переменной uni (true), предполагая, что элемент уникален. Если элемент не уникален - uni становится ложным и совершается выход из цикла. Иначе - увеличиваем счетчик на 1. Пройдя весь массив, программа выводит общее количество уникальных значений всего массива.

4. **Подсчет суммы и уникальных значений столбцов**      
   Программа создает два новых массива: sums - суммы столбцов и unicount - уникальные элементы в столбце (каждом). Используя цикл от 0 до M-1, вложенный цикл для суммирования, и инициализируя три новых переменных sum, countJ, isUnique (false) мы заполняем новые массивы (для каждого элемента: добавляем его значение к sum, проверяем уникальность, увеличиваем счетчик на 1).         

5. **Сортировка**    
   Программа выводит элементы двумерного массива по диагоналям. Сначала обрабатываются диагонали, начиная с первой строки верхнего ряда. Переменные x и y используются для перемещения по диагонали (x растет на 1, а y уменьшается на 1). После этого программа обрабатывает оставшиеся диагонали, начиная с первого столбца (второй строки и ниже). Каждый элемент выводится на экран и после завершения диагонали добавляется перевод строки.                                                 
6. **Вывод факториалов**
   Программа вычисляет факториалы для каждого элемента. Циклом (вложенным) вычисляется факториал, перемножая числа от 1 до значения элемента. Результат выводится и добавляется перевод строки, если диагональ заканчивается. Если число меньше 0 - вывод символа #. 

### 5. Программа 
```java
import java.io.PrintStream;
import java.util.Scanner;

public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;

    public static void main(String[] args) {

        int N = in.nextInt();
        int M = in.nextInt();

        int[][] a = new int[N][M]; // создаем и считываем данные двумерного массива N*M
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                a[i][j] = in.nextInt();
            }
        }

        int count = 0; // переменная для подсчета уникальных значений массива

        for (int i = 0; i < N; i++) { // проходим по строке и столбцу
            for (int j = 0; j < M; j++) {
                boolean uni = true; // флаг для проверки уникальности
                for (int k = 0; k < i; k++) { // проверка прошлых строк и столбцов
                    for (int l = 0; l < M; l++) {
                        if (a[k][l] == a[i][j]) { // если нашли совпадение, то флаг - ложь и после этого следует выход из цикла
                            uni = false;
                            break;
                        }
                    }
                    if (!uni) { // элемент не уникален - выход
                        break;
                    }
                }
                for (int l = 0; l < j; l++) { // проверяем все предыдущие элементы в текущей строке
                    if (a[i][l] == a[i][j]) {
                        uni = false;
                        break;
                    }
                }
                if (uni) // если нашли уникальный - увеличиваем счетчик
                    count++;
            }
        }

        out.println("Кол-во уникальных значений: " + count);

        int[] sums = new int[M]; // массив для хранения сумм по столбцам
        int[] unicount = new int[M]; // массив для хранения ун. эл. по столбцам

        for (int j = 0; j < M; j++) { // цикл для вычисления сумм и ун. эл (по столбцам)
            int sum = 0; // сумма текущего столбца
            int countJ = 0; // кол-во ун. знач в текущем столбце

            for (int i = 0; i < N; i++) {  // по строкам
                sum += a[i][j]; // заполняем сумму столбца

                boolean isUnique = true; // флаг уникальности
                for (int k = 0; k < i; k++) { // аналогичный цикл нахождения уник. значений
                    if (a[k][j] == a[i][j]) {
                        isUnique = false;
                        break;
                    }
                }

                if (isUnique) {
                    countJ++;
                }
            }

            sums[j] = sum; // сохраняем сумму в массив
            unicount[j] = countJ; // сохраняем кол-во уникальных элементов в массив
        }

        for (int i = 0; i < M - 1; i++) { // проходим по столбцам
            for (int j = 0; j < M - 1 - i; j++) { // сравнение
                if (sums[j] > sums[j + 1] || (sums[j] == sums[j + 1] && unicount[j] < unicount[j + 1])) { // если сумма больше или суммы равны, но кол-во уникальных меньше => меняем местами

                    int temp = sums[j]; // метод пузырька для сумм
                    sums[j] = sums[j + 1];
                    sums[j + 1] = temp;

                    int tempus = unicount[j]; // метод пузырька для уникальных значений
                    unicount[j] = unicount[j + 1];
                    unicount[j + 1] = tempus;

                    for (int d = 0; d < N; d++) { // меняем столбцы в массиве
                        int temp1 = a[d][j];
                        a[d][j] = a[d][j + 1];
                        a[d][j + 1] = temp1;
                    }
                }
            }
        }

        out.println("Массив диагоналей:"); // начинаем вывод массива по диагонали

        for (int colonka = 0; colonka < M; colonka++) { // вывод верхнего ряда, проход по каждому столбцу в верхнем ряду
            int x = 0, y = colonka; // переменные для координат
            while (x < N && y >= 0) { // пока не выйдем из массива выводим
                out.print(a[x][y] + " ");
                x++; // переход к след строке
                y--; // переход к след столбцу
            }
            out.println();
        }

        for (int ryad = 1; ryad < N; ryad++) { // начинаем со 2 строки
            int x = ryad, y = M - 1; // текущая строка и последний столбец
            while (x < N && y >= 0) {
                out.print(a[x][y] + " ");
                x++;
                y--;
            }
            out.println();
        }

        out.println("Массив с факториалами диагоналей:");
        for (int colonka = 0; colonka < M; colonka++) { // аналогичный цикл прошлому, но теперь вывод факториалов этих элементов
            int x = 0, y = colonka;
            while (x < N && y >= 0) {
                if (a[x][y] < 0) {
                    out.print("# "); // выводим # для отрицательных значений
                } else {
                    long factorial = 1;

                    // проверка на случай, если a[x][y] равно 0
                    if (a[x][y] == 0) {
                        factorial = 1; // факториал 0 равен 1
                    } else {
                        for (int k = 1; k <= a[x][y]; k++) {
                            factorial *= k;
                        }
                    }
                    out.print(factorial + " "); // выводим факториал
                }
                x++;
                y--;
            }
            out.println();
        }

        for (int ryad = 1; ryad < N; ryad++) {
            int x = ryad, y = M - 1;

            while (x < N && y >= 0) {
                if (a[x][y] < 0) {
                    out.print("# "); // выводим # для отрицательных значений
                } else {
                    long factorial = 1;

                    // проверка на случай, если a[x][y] равно 0
                    if (a[x][y] == 0) {
                        factorial = 1; // факториал 0 равен 1
                    } else {
                        for (int k = 1; k <= a[x][y]; k++) {
                            factorial *= k;
                        }
                    }
                    out.print(factorial + " "); // выводим факториал
                }
                x++;
                y--;
            }
            out.println();
        }
    }
}
```

### 6. Анализ правильности решения
  Итак, для проверки правильности решения возьмем предельные значения a[i][j]. Также вспомним, что мы ограничили на ввод числа a[i][j] <= 0.

1. Тест на базовый случай (числа идут по порядку, столбцы не должны меняться местами).
   **Input**:
        ```
       3 3
       1 2 3
       4 5 6
       7 8 9
        ```
    
   **Output**:
      ```
    Кол-во уникальных значений: 9
    Массив диагоналей:
    1 
    2 4 
    3 5 7 
    6 8 
    9 
    Массив с факториалами диагоналей:
    1 
    2 24 
    6 120 5040 
    720 40320 
    362880  
      ```
2. Тест на случай, когда нужно менять стобцы местами, но все числа уникальны.
   **Input**:
       ```
        3 3
        9 8 7
        6 5 4 
        3 2 1
       ```
   **Output**:
      ```
    Кол-во уникальных значений: 9
    Массив диагоналей:
    7 
    8 4 
    9 5 1 
    6 2 
    3 
    Массив с факториалами диагоналей:
    5040 
    40320 24 
    362880 120 1 
    720 2 
    6 
      ```
3. Тест на случай, когда нужно менять стобцы местами, разное количество уникальных чисел.
   **Input**:
       ```
        3 3 
        1 2 3
        4 5 3
        9 0 1
       ```
   **Output**:
      ```
    Кол-во уникальных значений: 7
    Массив диагоналей:
    2 
    3 5 
    1 3 0 
    4 1 
    9 
    Массив с факториалами диагоналей:
    2 
    6 120 
    1 6 1 
    24 1 
    362880  
      ```
4. Тест на случай, когда нет уникальных чисел.
   **Input**:
       ```
        3 3 
        1 2 3
        4 5 3
        9 0 1
       ```
   **Output**:
      ```
    Кол-во уникальных значений: 1
    Массив диагоналей:
    1 
    1 1 
    1 1 1 
    1 1 
    1 
    Массив с факториалами диагоналей:
    1 
    1 1 
    1 1 1 
    1 1 
    1   
      ```
5. Тест на предельные значения a[i][j].
   **Input**:
       ```
        3 3 
        1 2 3
        4 5 3
        9 0 12
       ```
   **Output**:
      ```
    Кол-во уникальных значений: 9
    Массив диагоналей:
    1 
    2 4 
    3 5 7 
    6 8 
    12 
    Массив с факториалами диагоналей:
    1 
    2 24 
    6 120 5040 
    720 40320 
    479001600 
      ```
6. Тест на большие значения N и M.
   **Input**:
       ```
        10 10
    4 0 1 10 2 9 8 3 6 7
    8 0 5 4 1 2 9 10 6 7
    7 5 10 1 4 8 3 9 6 0
    9 1 3 6 7 8 4 10 2 5
    10 4 7 3 5 6 8 0 9 1
    8 5 3 9 0 2 10 1 4 7
    9 6 1 3 2 10 4 5 7 8
    1 8 9 5 4 6 2 3 0 10
    8 0 10 2 5 1 6 7 3 9
    7 5 0 10 4 3 9 1 8 2
       ```
   **Output**:
      ```
    Кол-во уникальных значений: 11
    Массив диагоналей:
    0 
    2 0 
    1 1 5 
    3 5 4 1 
    6 10 10 7 4 
    10 6 9 3 5 5 
    9 4 6 10 7 0 6 
    7 2 1 2 0 3 2 8 
    8 7 8 6 9 1 1 4 0 
    4 9 0 8 3 4 5 9 5 5 
    8 3 5 6 9 7 3 10 4 
    7 4 1 2 3 0 7 0 
    9 8 7 10 5 3 1 
    10 10 8 6 2 8 
    8 4 10 1 10 
    9 2 9 3 
    1 6 2 
    8 9 
    7 
    Массив с факториалами диагоналей:
    1 
    2 1 
    1 1 120 
    6 120 24 1 
    720 3628800 3628800 5040 24 
    3628800 720 362880 6 120 120 
    362880 24 720 3628800 5040 1 720 
    5040 2 1 2 1 6 2 40320 
    40320 5040 40320 720 362880 1 1 24 1 
    24 362880 1 40320 6 24 120 362880 120 120 
    40320 6 120 720 362880 5040 6 3628800 24 
    5040 24 1 2 6 1 5040 1 
    362880 40320 5040 3628800 120 6 1 
    3628800 3628800 40320 720 2 40320 
    40320 24 3628800 1 3628800 
    362880 2 362880 6 
    1 720 2 
    40320 362880 
    5040  
      ```
7. Тест на минимальное значения N и M.
   **Input**:
       ```
        1 1
        0
       ```
   **Output**:
      ```
    Кол-во уникальных значений: 1
    Массив диагоналей:
    0 
    Массив с факториалами диагоналей:
    1  
      ```        
8. Тест на отрицательные значения в N и M.
   **Input**:
       ```
     3 3 
        1 2 3 
        4 5 6
        7 8 -2
       ```
   **Output**:
      ```
    Кол-во уникальных значений: 9
      Массив диагоналей:
      3 
      1 6 
      2 4 -2 
      5 7 
      8 
      Массив с факториалами диагоналей:
      6 
      1 720 
      2 24 # 
      120 5040 
      40320 

      ```   
